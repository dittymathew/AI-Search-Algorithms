#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<sstream>
#include <fstream>
#include "tsp.h"
using namespace std;

int* Solution::Initialize(int *list)
{

	int *visited = new int [no];
	int i,j,mincity,current;
	double tourcost,mincost;
	///Initialize visited of every city to 0
	for(i=0;i<=no;i++)
	{
		visited[i]=0;
		
	}
	
	current=0;	
	list[0]=current;
	
	for(i=0;i<no;i++)
	{
		visited[current]=1;
		mincost=0;
		mincity=0;
		///Find nearest neighbour to current city considered
		for(j=0;j<no;j++)
		{
			if(visited[j]==0 && current !=j) 
			{	
				if(mincost==0) 
				{
					mincost =dist_matrix[current][j];
					mincity =j;
				}
				if(dist_matrix[current][j]<mincost && visited[j]!=1)
				{
					mincost=dist_matrix[current][j];
					mincity=j;
				}
			}
		
		}
		if(mincity !=0){
		current=mincity;
		list[i+1]=mincity;
		}
	}
	cout<<Evaluate(list)<<"\n";
	return list;

}

/**
 *Purpose : To generate initial solution, using random generation a solution is obtained which is used as the starting point for simulated annealing
 * Return:Path generated by random generator
 * */
int* Solution::randomgen(int *tour)
{
	int i,v1,v2,temp;
	for(i=0;i<no;i++)
		tour[i]=i;
	for(i=0;i<no;i++)
	{
		v1=rand() % no;
		v2=rand() % no;
		temp =tour[v1];
		tour[v1]=tour[v2];
		tour[v2]=temp;
	}
	return tour;
}

/**
 *Purpose : To perform 2 opt swap-to perturb a path
 *Input Argument:The path to be perturbed using 2 opt 
 * Return:Path generated after perturbing
 * */

int* Solution::twooptswap(int *copy,int *tour)
{
	///Generate random numbers 
	int v1=rand() % no;
	int v2=rand() % no;
	int k,i,j;
	
	int temp;

	if(v1!=v2)
	{
		if(v1>v2)
		{
			k=0;
			for(i=v1;i<no;i++)
			{
				copy[k]=tour[i];
				k++;
			}
			for(i=0;i<v1;i++)
			{
				copy[k]=tour[i];
				k++;
			}
			v2+=(no-v1);
			v1=0;

		}
		for(k=v1,i=v2;k<i;k++,i--)
		{
			temp=copy[k];
			copy[k]=copy[i];
			copy[i]=temp;
		}
		
	}
	else{
	for(k=0;k<no;k++)
	{
		copy[k]=tour[k];
	}
	}
	return copy;
}


int* Solution::twooptswap(int *copy,int *tour,int v1,int v2)
{
	///Generate random numbers 
//	int v1=rand() % no;
//	int v2=rand() % no;
	int k,i,j;
	
	int temp;

	if(v1!=v2)
	{
		if(v1>v2)
		{
			k=0;
			for(i=v1;i<no;i++)
			{
				copy[k]=tour[i];
			//	if(v1==1 && v2==0)
			//		cout<<"\nFirst loop:"<<copy[k]+1;
				k++;
			}
			for(i=0;i<v1;i++)
			{
				copy[k]=tour[i];
			//	if(v1==1 && v2==0)
			//		cout<<"\nSecond loop:  "<<copy[k]+1;
				k++;
			}
			//if(v1==1 && v2==0){
		//	for(i=0;i<k;i++)
		//	{
		//		cout<<copy[i]+1<<"\t";
		//	}
		//	cout<<"\n";}
			v2+=(no-v1);
			v1=0;
//			cout<<"In two opt"<<v1<<" "<<v2<<" \n";
		}
		for(k=v1,i=v2;k<i;k++,i--)
		{
			temp=copy[k];
			copy[k]=copy[i];
			copy[i]=temp;
		}
		
	}


	return copy;
}
/**
 *Purpose : To evaluate a tour generated
 *Input Argument: Tour to be evaluated
* Return:Cost of tour in terms of distance of whole tour
 * */
double Solution::Evaluate(int *current)
{
	double sum=0.0;
	int i=0,index1=0,ind=0;
	for(i=0;i<no-1;i++)
	{
	      index1=current[i];
	      ind=current[i+1];
		  
	      sum=sum+dist_matrix[index1][ind];
	}
	index1=i;
	ind=0;
	sum=sum+dist_matrix[index1][ind];
	return sum;
}

